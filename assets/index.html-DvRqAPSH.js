import{_ as t,c as r,a as o,o as s}from"./app--GtHkUG5.js";const a={};function c(p,e){return s(),r("div",null,e[0]||(e[0]=[o("<p>从 <code>.dat</code> 最终得到 JSON，实际走的是一条“二进制 → 提取字符串 → 解密 → JSON.parse”的流水线。你现在这个项目里对应的代码基本都在 [app.js](file:///d:/Projects/TraeProjects/parse/src/app.js)。</p><p><strong>1）把 .dat 读成字节数组</strong></p><ul><li>用户选择文件后触发 <code>datFile</code> 的 change 事件：[app.js:L251-L285](file:///d:/Projects/TraeProjects/parse/src/app.js#L251-L285)</li><li><code>file.arrayBuffer()</code> 读到原始二进制，然后 <code>new Uint8Array(buffer)</code> 变成字节数组 <code>raw</code></li></ul><p><strong>2）在二进制里“抠出”编码串（通常是 Base64 文本）</strong></p><ul><li><code>extractBinaryFormatterString(raw)</code>：[app.js:L51-L75](file:///d:/Projects/TraeProjects/parse/src/app.js#L51-L75)</li><li>做法是： <ul><li>从头扫描字节，找到 token <code>0x06</code>（你这里当作 BinaryFormatter 的 string 标记）：[app.js:L1](file:///d:/Projects/TraeProjects/parse/src/app.js#L1)</li><li>计算 <code>strlenOffset = i + 5</code>，从这个位置开始读取“7-bit 变长整数”作为字符串长度：<code>read7bitEncodedInt</code>：[app.js:L26-L38](file:///d:/Projects/TraeProjects/parse/src/app.js#L26-L38)</li><li>按长度切出那段 UTF-8 字节，再 <code>TextDecoder(&quot;utf-8&quot;)</code> 解码成 JS 字符串 <code>decoded</code>（这就是你要的“编码串”）：[app.js:L61-L65](file:///d:/Projects/TraeProjects/parse/src/app.js#L61-L65)</li></ul></li><li>同时它还保存了 <code>header</code> 和 <code>footer</code>，用于后面导出时保持文件其它结构不变：[app.js:L65-L71](file:///d:/Projects/TraeProjects/parse/src/app.js#L65-L71)</li></ul><p><strong>3）把“编码串”解密成 JSON 文本</strong></p><ul><li>先从界面读取当前配置（算法、key、编码方式）：<code>getCryptoConfig()</code>：[app.js:L77-L82](file:///d:/Projects/TraeProjects/parse/src/app.js#L77-L82)</li><li><code>decryptText(extracted.encoded, cfg)</code>：[app.js:L141-L160](file:///d:/Projects/TraeProjects/parse/src/app.js#L141-L160) <ul><li>如果你选的是 AES-ECB/Pkcs7： <ul><li>先把 Base64/Hex/Base64URL 文本还原成“密文字节”（CryptoJS 的 WordArray）：<code>parseCiphertextToWordArray</code>：[app.js:L92-L97](file:///d:/Projects/TraeProjects/parse/src/app.js#L92-L97)</li><li>再用 <code>CryptoJS.AES.decrypt</code> + <code>ECB</code> + <code>Pkcs7</code> + key 解出 UTF-8 明文字符串：[app.js:L150-L158](file:///d:/Projects/TraeProjects/parse/src/app.js#L150-L158)</li></ul></li><li>解密出来的结果在这里被命名为 <code>jsonText</code>：[app.js:L266-L268](file:///d:/Projects/TraeProjects/parse/src/app.js#L266-L268)</li></ul></li></ul><p><strong>4）把 JSON 文本变成“可编辑、格式化”的 JSON</strong></p><ul><li>这里严格来说分两步： <ul><li><code>JSON.parse(jsonText)</code> 验证它确实是合法 JSON</li><li><code>JSON.stringify(obj, null, 2)</code> 变成带缩进的漂亮格式</li></ul></li><li>你代码里封装成了 <code>tryPrettyJson(text)</code>：[app.js:L190-L193](file:///d:/Projects/TraeProjects/parse/src/app.js#L190-L193)</li><li>最后把格式化后的 JSON 放进右侧文本框 <code>datJson</code>：[app.js:L268](file:///d:/Projects/TraeProjects/parse/src/app.js#L268)</li></ul><p>一句话总结：<br><strong><code>.dat</code> 里藏着“加密后的编码字符串” → 先按 BinaryFormatter 结构把字符串取出来 → 按你选的编码（Base64/Hex）还原密文 → 用 AES+key 解密得到 JSON 字符串 → JSON.parse 成对象并格式化显示。</strong></p>",10)]))}const d=t(a,[["render",c]]),l=JSON.parse('{"path":"/notes/games/hollow_knight/silk_song/save_parse/","title":"存档解析","lang":"zh-CN","frontmatter":{"title":"存档解析","createTime":"2026/01/13 15:59:49","permalink":"/notes/games/hollow_knight/silk_song/save_parse/","description":"从 .dat 最终得到 JSON，实际走的是一条“二进制 → 提取字符串 → 解密 → JSON.parse”的流水线。你现在这个项目里对应的代码基本都在 [app.js](file:///d:/Projects/TraeProjects/parse/src/app.js)。 1）把 .dat 读成字节数组 用户选择文件后触发 datFile 的 ch...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"存档解析\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-01-13T09:31:52.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://nov1ce-lee.github.io/notes/games/hollow_knight/silk_song/save_parse/"}],["meta",{"property":"og:site_name","content":"novice.log"}],["meta",{"property":"og:title","content":"存档解析"}],["meta",{"property":"og:description","content":"从 .dat 最终得到 JSON，实际走的是一条“二进制 → 提取字符串 → 解密 → JSON.parse”的流水线。你现在这个项目里对应的代码基本都在 [app.js](file:///d:/Projects/TraeProjects/parse/src/app.js)。 1）把 .dat 读成字节数组 用户选择文件后触发 datFile 的 ch..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-13T09:31:52.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-13T09:31:52.000Z"}]]},"readingTime":{"minutes":1.86,"words":558},"git":{"createdTime":1768296712000,"updatedTime":1768296712000,"contributors":[{"name":"novice","username":"novice","email":"289836737@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/novice?v=4","url":"https://github.com/novice"}]},"autoDesc":true,"filePathRelative":"notes/game/空洞骑士系列/2.丝之歌/游戏解析/2.存档解析.md","headers":[]}');export{d as comp,l as data};
